<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Sanmathi – Industry Portfolio</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body.dark { background:#0a0a0a; color:#fff; }
    body.light { background:#f5f5f5; color:#000; }
    body { margin:0; font-family:'Segoe UI',sans-serif; transition:background 0.3s,color 0.3s; }

    header { text-align:center; padding:40px 20px; }
    header h1 { font-size:42px; font-weight:900; color:#ff4c60; }
    header h3 { font-size:22px; font-weight:600; color:#ffdd57; }
    header p { max-width:800px; margin:20px auto; font-size:16px; line-height:1.6; }

    .theme-toggle { margin-top:15px; padding:10px 20px; border:none; border-radius:8px;
      cursor:pointer; font-weight:bold; background:#5ac8fa; color:#fff; }

    .card-container { display:flex; flex-wrap:wrap; justify-content:center; gap:20px; padding:20px; }
    .card { border-radius:15px; width:250px; padding:20px; text-align:center; cursor:pointer; color:#fff;
      box-shadow:0 0 20px rgba(0,0,0,0.4); transition:transform 0.3s ease; }
    .card:hover { transform:translateY(-5px); }

    /* Button colors */
    .card:nth-child(1){background:#ff4c60;} .card:nth-child(2){background:#4cd964;}
    .card:nth-child(3){background:#5ac8fa;} .card:nth-child(4){background:#a970ff;}
    .card:nth-child(5){background:#ff9500;} .card:nth-child(6){background:#ffd60a;color:#000;}
    .card:nth-child(7){background:#64d2ff;}

    /* Module content tinted with same color */
    .module-content { display:none; margin:20px auto; padding:20px; border-radius:12px; max-width:900px; }
    #m1{background:rgba(255,76,96,0.2);} #m2{background:rgba(76,217,100,0.2);}
    #m3{background:rgba(90,200,250,0.2);} #m4{background:rgba(169,112,255,0.2);}
    #m5{background:rgba(255,149,0,0.2);} #m6{background:rgba(255,214,10,0.2);}
    #m7{background:rgba(100,210,255,0.2);}

    pre { background:rgba(0,0,0,0.2); padding:15px; border-radius:10px; overflow-x:auto; font-size:14px; text-align:left; }
    body.light pre { background:rgba(0,0,0,0.05); }

    /* Back to Home button styles */
    .back-home {
      position: absolute;
      top: 20px;
      right: 20px;
      padding: 10px 18px;
      background: #ff4c60;
      color: #fff;
      border-radius: 8px;
      font-weight: bold;
      text-decoration: none;
      transition: background 0.3s ease, transform 0.2s ease;
    }
    .back-home:hover {
      background: #ff1e3c;
      transform: scale(1.05);
    }
    body.light .back-home {
      background: #00aaff;
      color: #fff;
    }
    body.light .back-home:hover {
      background: #0077cc;
    }
  </style>
</head>
<body class="dark">

  <!-- Back to Home button -->
  <a href="index.html" class="back-home">⬅ Back to Home</a>
<header>
  <h1>Sanmathi</h1>
  <h3>Industrial & Manufacturing Systems – Vishalnagari</h3>
  <p>
    Vishalnagari’s industries face challenges in scheduling, routing, resource allocation, and predictive maintenance.  
    This portfolio explores how algorithms transform these business cases into scalable, efficient solutions.
  </p>
  <button class="theme-toggle" onclick="toggleTheme()">Switch Theme</button>
</header>

<div class="card-container">
  <div class="card" onclick="toggleModule('m1')">Module 1: EV Assembly Line</div>
  <div class="card" onclick="toggleModule('m2')">Module 2: Machine Job Scheduling</div>
  <div class="card" onclick="toggleModule('m3')">Module 3: Logistics Routing</div>
  <div class="card" onclick="toggleModule('m4')">Module 4: Battery Allocation</div>
  <div class="card" onclick="toggleModule('m5')">Module 5: Predictive Maintenance</div>
  <div class="card" onclick="toggleModule('m6')">Module 6: Workforce Scheduling</div>
  <div class="card" onclick="toggleModule('m7')">Module 7: Supply Chain Optimization</div>
</div>
<div id="m1" class="module-content">
  <h2>EV Assembly Line Optimization</h2>
  <p><strong>Case Study:</strong><br>
  How can tasks be sequenced so robots never wait idly and bottlenecks vanish?</p>
  <p><strong>Algorithm:</strong> Topological Sort (Kahn’s Algorithm)<br><strong>Efficiency:</strong> O(V+E)</p>
  <pre>
C++ Pseudocode:
vector<int> topologicalSort(int V, vector<vector<int>>& adj) {
    vector<int> in_degree(V, 0);
    for (int u = 0; u < V; u++)
        for (int v : adj[u]) in_degree[v]++;
    queue<int> q;
    for (int i = 0; i < V; i++) if (in_degree[i] == 0) q.push(i);
    vector<int> result;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        result.push_back(u);
        for (int v : adj[u]) {
            if (--in_degree[v] == 0) q.push(v);
        }
    }
    return result;
}
  </pre>
  <p><strong>Conclusion:</strong><br>
  Topological sort ensures smooth EV assembly, minimizing idle time and maximizing throughput.</p>
</div>
      <div id="m2" class="module-content">
  <h2>General Machine Job Scheduling</h2>
  <p><strong>Case Study:</strong><br>
  How can factories assign overlapping jobs to machines so no energy is wasted?</p>
  <p><strong>Algorithm:</strong> Interval Scheduling (Greedy)<br><strong>Efficiency:</strong> O(n log n)</p>
  <pre>
C++ Pseudocode:
struct Job { int start, finish; };
bool compare(Job a, Job b){ return a.finish < b.finish; }
vector<Job> intervalScheduling(vector<Job>& jobs) {
    sort(jobs.begin(), jobs.end(), compare);
    vector<Job> result; int lastFinish = -1;
    for (Job j : jobs) {
        if (j.start >= lastFinish) {
            result.push_back(j);
            lastFinish = j.finish;
        }
    }
    return result;
}
  </pre>
  <p><strong>Conclusion:</strong><br>
  Greedy scheduling ensures machines run continuously without conflict, boosting efficiency.</p>
</div>
      <div id="m3" class="module-content">
  <h2>Logistics Routing Optimization</h2>
  <p><strong>Case Study:</strong><br>
  How can trucks deliver goods across mills without wasting fuel or time?</p>
  <p><strong>Algorithm:</strong> Dijkstra’s Shortest Path<br><strong>Efficiency:</strong> O(E+V log V)</p>
  <pre>
C++ Pseudocode:
vector<int> dijkstra(int V, vector<vector<pair<int,int>>>& adj, int src) {
    vector<int> dist(V, INT_MAX);
    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<>> pq;
    dist[src] = 0; pq.push({0, src});
    while (!pq.empty()) {
        int u = pq.top().second; pq.pop();
        for (auto [v, wt] : adj[u]) {
            if (dist[u] + wt < dist[v]) {
                dist[v] = dist[u] + wt;
                pq.push({dist[v], v});
            }
        }
    }
    return dist;
}
  </pre>
  <p><strong>Conclusion:</strong><br>
  Dijkstra’s ensures trucks take shortest routes, cutting costs and speeding deliveries.</p>
</div>
              <div id="m4" class="module-content">
  <h2>EV Battery Allocation</h2>
  <p><strong>Case Study:</strong><br>
  EV factories face shortages when battery packs are unevenly distributed.  
  How can limited batteries be allocated fairly across zones?  
  Can we maximize flow to balance demand?</p>

  <p><strong>Algorithm:</strong> Max Flow (Ford–Fulkerson)<br>
     <strong>Efficiency:</strong> O(E × max_flow)</p>

  <pre>
C++ Pseudocode:
int fordFulkerson(vector<vector<int>>& capacity, int s, int t) {
    int V = capacity.size();
    vector<vector<int>> residual = capacity;
    int max_flow = 0;
    while (true) {
        vector<int> parent(V, -1);
        queue<int> q; q.push(s); parent[s] = s;
        while (!q.empty() && parent[t] == -1) {
            int u = q.front(); q.pop();
            for (int v = 0; v < V; v++) {
                if (parent[v] == -1 && residual[u][v] > 0) {
                    parent[v] = u; q.push(v);
                }
            }
        }
        if (parent[t] == -1) break;
        int path_flow = INT_MAX;
        for (int v = t; v != s; v = parent[v]) {
            int u = parent[v];
            path_flow = min(path_flow, residual[u][v]);
        }
        for (int v = t; v != s; v = parent[v]) {
            int u = parent[v];
            residual[u][v] -= path_flow;
            residual[v][u] += path_flow;
        }
        max_flow += path_flow;
    }
    return max_flow;
}
  </pre>

  <p><strong>Conclusion:</strong><br>
  Max Flow ensures batteries are distributed optimally, balancing demand across all zones.</p>
</div>
              <div id="m5" class="module-content">
  <h2>Predictive Maintenance</h2>
  <p><strong>Case Study:</strong><br>
  Looms and dyeing machines often fail unexpectedly.  
  Can we predict failures before they occur?  
  How can data guide proactive maintenance?</p>

  <p><strong>Algorithm:</strong> Decision Tree Classification<br>
     <strong>Efficiency:</strong> O(n log n) training, O(log n) prediction</p>

  <pre>
C++ Pseudocode:
struct Node {
    string feature;
    string label;
    Node* left;
    Node* right;
};

string predict(Node* root, map<string,string>& input) {
    while (root->left && root->right) {
        if (input[root->feature] == "yes") {
            root = root->left;
        } else {
            root = root->right;
        }
    }
    return root->label;
}
  </pre>

  <p><strong>Conclusion:</strong><br>
  Decision trees forecast failures early, enabling proactive maintenance and reducing costly downtime.</p>
</div>
<div id="m6" class="module-content">
  <h2>Workforce Scheduling</h2>
  <p><strong>Case Study:</strong><br>
  Workers need fair shifts without excessive overtime.  
  How can we assign tasks respecting availability?  
  Can we minimize cost while balancing workloads?</p>

  <p><strong>Algorithm:</strong> Hungarian Algorithm (Assignment Problem)<br>
     <strong>Efficiency:</strong> O(n³)</p>

  <pre>
C++ Pseudocode:
int hungarian(const vector<vector<int>>& cost) {
    int n = cost.size();
    vector<int> u(n+1), v(n+1), p(n+1), way(n+1);
    for (int i=1; i<=n; i++) {
        p[0] = i; int j0 = 0;
        vector<int> minv(n+1, INT_MAX);
        vector<bool> used(n+1, false);
        do {
            used[j0] = true;
            int i0 = p[j0], delta = INT_MAX, j1 = 0;
            for (int j=1; j<=n; j++) {
                if (!used[j]) {
                    int cur = cost[i0-1][j-1]-u[i0]-v[j];
                    if (cur < minv[j]) { minv[j] = cur; way[j] = j0; }
                    if (minv[j] < delta) { delta = minv[j]; j1 = j; }
                }
            }
            for (int j=0; j<=n; j++) {
                if (used[j]) { u[p[j]] += delta; v[j] -= delta; }
                else { minv[j] -= delta; }
            }
            j0 = j1;
        } while (p[j0] != 0);
        do {
            int j1 = way[j0]; p[j0] = p[j1]; j0 = j1;
        } while (j0);
    }
    return -v[0];
}
  </pre>

  <p><strong>Conclusion:</strong><br>
  The Hungarian algorithm ensures fair and efficient workforce scheduling across employees.</p>
</div><div id="m7" class="module-content">
  <h2>Supply Chain Optimization</h2>
  <p><strong>Case Study:</strong><br>
  Raw materials must flow across multiple factories.  
  How can we minimize cost while meeting demand?  
  Can linear programming balance supply and demand?</p>

  <p><strong>Algorithm:</strong> Linear Programming (Simplex Method)<br>
     <strong>Efficiency:</strong> Polynomial average time</p>

  <pre>
C++ Pseudocode (conceptual):
// Variables: flow[i][j] = amount shipped from source i to destination j
// Objective: minimize sum(cost[i][j] * flow[i][j])
// Constraints:
//   - Supply limits at each source
//   - Demand requirements at each destination
//   - Non-negativity of flows
// Use simplex method or LP solver library to solve
// Return optimal flows and minimum cost
  </pre>

  <p><strong>Conclusion:</strong><br>
  Linear programming minimizes costs while ensuring supply meets demand across the chain.</p>
</div>
<section style="margin:40px auto; max-width:900px; padding:20px;
                background:rgba(255,255,255,0.05); border-radius:15px;">
  <h2>Conclusion</h2>
  <p>
    Each module demonstrates how algorithmic thinking solves real industrial challenges in Vishalnagari.  
    From assembly lines to supply chains, these solutions reduce waste, save time, and improve efficiency.
  </p>
</section>

<script>
function toggleModule(id) {
  const modules = document.getElementsByClassName('module-content');
  for (let m of modules) m.style.display = "none";
  const target = document.getElementById(id);
  if (target) target.style.display = "block";
}

function toggleTheme() {
  const body = document.body;
  if (body.classList.contains("dark")) {
    body.classList.remove("dark"); body.classList.add("light");
  } else {
    body.classList.remove("light"); body.classList.add("dark");
  }
}
</script>
</body>
</html>
