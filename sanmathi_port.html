<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Sanmathi ‚Äì Industry & Infrastructure Portfolio</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    /* Basic page styling */
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background-color: #0a0a0a; /* dark background */
      color: #ffffff;            /* white text */
      text-align: center;
    }

    /* Header section */
    header {
      padding: 40px 20px;
    }
    header h1 {
      font-size: 36px;
      font-weight: bold;
      color: #f39c12; /* orange accent */
    }
    header h3 {
      font-size: 20px;
      font-weight: 600;
      color: #1abc9c; /* teal accent */
    }
    header p {
      max-width: 800px;
      margin: 20px auto;
      font-size: 16px;
      line-height: 1.5;
      color: #dddddd;
    }

    /* Module content (hidden by default) */
    .module-content {
      display: none;
      margin: 20px auto;
      padding: 20px;
      border-radius: 10px;
      max-width: 900px;
      background: rgba(255,255,255,0.05);
      color: #fff;
    }
    .module-content h2 {
      font-size: 22px;
    }
    .module-content p {
      font-size: 15px;
      line-height: 1.5;
    }
    pre {
      background: rgba(255,255,255,0.1);
      padding: 10px;
      border-radius: 8px;
      overflow-x: auto;
      font-size: 14px;
      color: #f5f5f5;
      text-align: left;
    }
  </style>
</head>
<body>

<header>
  <h1>Sanmathi Hegde</h1>
  <h3>Industry & Infrastructure ‚Äì Vishalnagari</h3>
  <p>
    Vishalnagari is a major industrial hub. From textiles to electric mobility, each sector faces challenges in scheduling, routing, resource allocation, and maintenance.  
    This portfolio presents algorithmic solutions that make these systems efficient, scalable, and reliable.  
    Modules cover assembly lines, textile dyeing, routing, allocation, predictive maintenance, workforce scheduling, and supply chain optimization.  
    Each solution applies proven algorithms from graph theory, optimization, and machine learning.  
    Together, they demonstrate how computation strengthens Vishalnagari‚Äôs industrial backbone.
  </p>
</header>
<!-- Module 1 -->
<div id="m1" class="module-content ev-box">
  <h2>EV Assembly Line Optimization</h2>
  <p><strong>üîç What exact problem are we solving?</strong><br>
  How can we sequence electric vehicle assembly tasks to minimize idle time and eliminate bottlenecks?</p>
  <p><strong>Algorithm:</strong> Topological Sort (Kahn‚Äôs Algorithm)<br>
     <strong>Efficiency:</strong> O(V + E)</p>
  <pre>
Pseudocode:
1. Compute in-degree of tasks
2. Push tasks with in-degree 0 into queue
3. While queue not empty:
   Pop task, add to result
   Reduce in-degree of neighbors

C++:
vector<int> topologicalSort(int V, vector<vector<int>>& adj) {
  vector<int> in_degree(V, 0);
  for (int u = 0; u < V; u++)
    for (int v : adj[u]) in_degree[v]++;
  queue<int> q;
  for (int i = 0; i < V; i++)
    if (in_degree[i] == 0) q.push(i);
  vector<int> result;
  while (!q.empty()) {
    int u = q.front(); q.pop();
    result.push_back(u);
    for (int v : adj[u])
      if (--in_degree[v] == 0) q.push(v);
  }
  return result;
}
  </pre>
</div>

<!-- Module 2 -->
<div id="m2" class="module-content">
  <h2>Module 2: Textile Dyeing Optimization</h2>
  <p>
    <strong>üîç Problem:</strong> In Vishalnagari‚Äôs textile sector, dyeing machines must process batches of fabric with varying colors and chemical requirements.  
    The challenge is to schedule dyeing jobs to minimize machine cleaning time and chemical waste.
  </p>
  <p>
    <strong>Algorithm:</strong> Job Sequencing with Minimum Setup Cost (Graph-based Scheduling)<br>
    <strong>Efficiency:</strong> O(n¬≤) for pairwise cost matrix + greedy traversal
  </p>
  <pre>
Pseudocode:
1. Represent each dyeing job as a node with color/chemical profile
2. Build a cost matrix: setup cost between every pair of jobs
3. Initialize empty schedule and mark all jobs unvisited
4. Choose starting job with lowest average setup cost
5. While unvisited jobs remain:
   a. From current job, pick next with minimum setup cost
   b. Add to schedule and mark as visited
6. Output final job sequence with minimized total setup cost
  </pre>

  <pre>
C++ (conceptual):
vector<int> optimizeDyeing(vector<vector<int>>& setupCost) {
  int n = setupCost.size();
  vector<bool> visited(n, false);
  vector<int> sequence;
  int current = 0;
  visited[current] = true;
  sequence.push_back(current);

  for(int step = 1; step < n; step++) {
    int next = -1, minCost = INT_MAX;
    for(int j = 0; j < n; j++) {
      if(!visited[j] && setupCost[current][j] < minCost) {
        minCost = setupCost[current][j];
        next = j;
      }
    }
    current = next;
    visited[current] = true;
    sequence.push_back(current);
  }
  return sequence;
}
  </pre>
</div>

<!-- Module 3 -->
<div id="m3" class="module-content cotton-box">
  <h2>Smart Cotton Inventory Routing</h2>
  <p><strong>üîç What exact problem are we solving?</strong><br>
  How can we route cotton from farms to mills with minimal transport cost and maximum throughput?</p>
  <p><strong>Algorithm:</strong> Dijkstra‚Äôs Algorithm<br>
     <strong>Efficiency:</strong> O(E + V log V)</p>
  <pre>
Pseudocode:
1. Initialize distances to ‚àû
2. Use priority queue to pick nearest node
3. Update neighbors if shorter path found

C++:
vector<int> dijkstra(int V, vector<vector<pair<int,int>>>& adj, int src) {
  vector<int> dist(V, INT_MAX);
  priority_queue<pair<int,int>, vector<pair<int,int>>, greater<>> pq;
  dist[src] = 0;
  pq.push({0, src});
  while (!pq.empty()) {
    int u = pq.top().second; pq.pop();
    for (auto [v, wt] : adj[u]) {
      if (dist[u] + wt < dist[v]) {
        dist[v] = dist[u] + wt;
        pq.push({dist[v], v});
      }
    }
  }
  return dist;
}
  </pre>
</div>
        <!-- Module 4 -->
<div id="m4" class="module-content battery-box">
  <h2>EV Battery Allocation Across Zones</h2>
  <p><strong>üîç What exact problem are we solving?</strong><br>
  How can we distribute battery packs to assembly zones based on demand and capacity?</p>
  <p><strong>Algorithm:</strong> Max Flow (Ford-Fulkerson)<br>
     <strong>Efficiency:</strong> O(E √ó max_flow)</p>
  <pre>
Pseudocode:
1. Initialize flow = 0
2. While augmenting path exists:
   Find path using BFS
   Update residual graph

C++:
int fordFulkerson(int s, int t, vector<vector<int>>& capacity) {
  int flow = 0;
  vector<vector<int>> residual = capacity;
  while (bfs(s, t, residual)) {
    int path_flow = INT_MAX;
    // trace path and find min capacity
    // update residual capacities
    flow += path_flow;
  }
  return flow;
}
  </pre>
</div>

<!-- Module 5 -->
<div id="m5" class="module-content predict-box">
  <h2>Predictive Maintenance in Textile Machines</h2>
  <p><strong>üîç What exact problem are we solving?</strong><br>
  How can we predict failures in textile machines (like looms and dyeing units) before they occur, reducing downtime?</p>
  <p><strong>Algorithm:</strong> Decision Tree Classification<br>
     <strong>Efficiency:</strong> O(n log n) training, O(log n) prediction</p>
  <pre>
Pseudocode:
1. Collect labeled sensor data
2. Train decision tree on failure patterns
3. For new input:
   Traverse tree ‚Üí predict risk
4. Schedule maintenance if risk > threshold

C++:
struct Node {
  string feature;
  Node* left;
  Node* right;
  string label;
};
string predict(Node* root, map<string,string>& input) {
  while (root->left && root->right) {
    if (input[root->feature] == "yes")
      root = root->left;
    else
      root = root->right;
  }
  return root->label;
}
  </pre>
</div>

<!-- Module 6 -->
<div id="m6" class="module-content workforce-box">
  <h2>Workforce Shift Scheduling</h2>
  <p><strong>üîç What exact problem are we solving?</strong><br>
  How can we assign workers to shifts fairly, respecting availability and minimizing overtime?</p>
  <p><strong>Algorithm:</strong> Hungarian Algorithm (Bipartite Matching)<br>
     <strong>Efficiency:</strong> O(n¬≥)</p>
  <pre>
Pseudocode:
1. Build cost matrix (workers √ó shifts)
2. Apply Hungarian algorithm to minimize total cost
3. Return optimal assignment

C++ (simplified):
int hungarian(const vector<vector<int>>& cost) {
  int n = cost.size();
  // Implementation of Hungarian algorithm
  // Returns minimum assignment cost
}
  </pre>
</div>
<!-- Module 7 -->
<div id="m7" class="module-content supply-box">
  <h2>Supply Chain Cost Minimization</h2>
  <p><strong>üîç What exact problem are we solving?</strong><br>
  How can we optimize raw material flow across multiple factories to minimize overall supply chain cost?</p>
  <p><strong>Algorithm:</strong> Linear Programming (Simplex Method)<br>
     <strong>Efficiency:</strong> Polynomial average time</p>
  <pre>
Pseudocode:
1. Define objective function: Minimize Œ£ (cost √ó flow)
2. Add constraints: demand, capacity, balance
3. Solve using simplex method
4. Return optimal flows

C++ (conceptual):
// Use LP solver library
// Define variables, constraints, objective
// Run simplex ‚Üí get solution
  </pre>
</div>
<!-- Conclusion -->
<section style="margin:40px auto; max-width:900px; padding:20px; background:rgba(255,255,255,0.05); border-radius:10px;">
  <h2>Conclusion</h2>
  <p>
    The Industry & Infrastructure portfolio demonstrates how Vishalnagari‚Äôs industrial hub can be strengthened through algorithmic solutions.  
    Modules address assembly lines, textile dyeing, routing, allocation, predictive maintenance, workforce scheduling, and supply chain optimization.  
    Each algorithm improves efficiency, reduces waste, and ensures scalable, reliable operations across diverse sectors.  
    Together, these modules highlight how computation supports Vishalnagari‚Äôs growth as a modern, resilient industrial ecosystem.
  </p>
</section>

<!-- Toggle Script -->
<script>
function toggleModule(id) {
  // Hide all modules first
  const modules = document.getElementsByClassName('module-content');
  for (let m of modules) {
    m.style.display = "none";
  }
  // Show the one you clicked
  const selected = document.getElementById(id);
  if (selected) {
    selected.style.display = "block";
  }
}
</script>

</body>
</html>
