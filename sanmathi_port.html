<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Sanmathi Hegde ‚Äì Industrial Portfolio</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      margin: 0;
      font-family: 'Segoe UI', sans-serif;
      background: #0a0a0a;
      color: #ffffff;
    }
    header {
      text-align: center;
      padding: 40px 20px;
    }
    header h1 {
      font-size: 42px;
      font-weight: 900;
      color: #ff79c6;
    }
    header h3 {
      font-size: 22px;
      font-weight: 600;
      color: #ffdd57;
    }
    header p {
      max-width: 800px;
      margin: 20px auto;
      font-size: 16px;
      line-height: 1.6;
      color: #dddddd;
    }
    .card-container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 20px;
      padding: 20px;
    }
    .card {
      background: rgba(30,30,30,0.85);
      border-radius: 15px;
      width: 250px;
      padding: 20px;
      text-align: center;
      cursor: pointer;
      box-shadow: 0 6px 20px rgba(0,0,0,0.6);
      transition: transform 0.3s ease;
    }
    .card:hover { transform: translateY(-5px); }
    .module-content {
      display: none;
      background: rgba(255,255,255,0.05);
      margin: 20px auto;
      padding: 20px;
      border-radius: 12px;
      max-width: 900px;
    }
    .module-content h2 { color: #8fd3f4; font-size: 24px; }
    .module-content p { font-size: 16px; line-height: 1.6; }
    pre {
      background: rgba(255,255,255,0.08);
      padding: 15px;
      border-radius: 10px;
      overflow-x: auto;
      font-size: 14px;
      color: #f5f5f5;
    }
  </style>
</head>
<body>

<header>
  <h1>Sanmathi Hegde</h1>
  <h3>Industrial & Manufacturing Systems ‚Äì Vishalnagari</h3>
  <p>
    Vishalnagari‚Äôs industrial ecosystem blends tradition and innovation ‚Äî from cotton textiles to electric mobility.  
    Each sector faces unique challenges in scheduling, routing, resource allocation, and predictive maintenance.  
    This portfolio explores how algorithmic thinking transforms these business cases into scalable, efficient solutions.  
    From graph theory to machine learning, each module applies logic to unlock smarter industrial systems.
  </p>
</header>

<div class="card-container">
  <div class="card" onclick="toggleModule('m1')">Module 1: EV Assembly Line</div>
  <div class="card" onclick="toggleModule('m2')">Module 2: Textile Dyeing</div>
  <div class="card" onclick="toggleModule('m3')">Module 3: Cotton Routing</div>
  <div class="card" onclick="toggleModule('m4')">Module 4: Battery Allocation</div>
  <div class="card" onclick="toggleModule('m5')">Module 5: Predictive Maintenance</div>
  <div class="card" onclick="toggleModule('m6')">Module 6: Workforce Scheduling</div>
  <div class="card" onclick="toggleModule('m7')">Module 7: Supply Chain Optimization</div>
</div>

<!-- Module 1 -->
<div id="m1" class="module-content">
  <h2>EV Assembly Line Optimization</h2>
  <p><strong>üîç What exact problem are we solving?</strong><br>
  How can we sequence electric vehicle assembly tasks to minimize idle time and eliminate bottlenecks?</p>
  <p><strong>Algorithm:</strong> Topological Sort (Kahn‚Äôs Algorithm)<br>
     <strong>Efficiency:</strong> O(V + E)</p>
  <pre>
Pseudocode:
1. Compute in-degree of tasks
2. Push tasks with in-degree 0 into queue
3. While queue not empty:
   Pop task, add to result
   Reduce in-degree of neighbors

C++:
vector<int> topologicalSort(int V, vector<vector<int>>& adj) {
  vector<int> in_degree(V, 0);
  for (int u = 0; u < V; u++)
    for (int v : adj[u]) in_degree[v]++;
  queue<int> q;
  for (int i = 0; i < V; i++)
    if (in_degree[i] == 0) q.push(i);
  vector<int> result;
  while (!q.empty()) {
    int u = q.front(); q.pop();
    result.push_back(u);
    for (int v : adj[u])
      if (--in_degree[v] == 0) q.push(v);
  }
  return result;
}
  </pre>
</div>

<!-- Module 2 -->
<div id="m2" class="module-content">
  <h2>Textile Dyeing Slot Scheduling</h2>
  <p><strong>üîç What exact problem are we solving?</strong><br>
  How can we assign dyeing slots to textile batches to minimize overlap and reduce energy usage?</p>
  <p><strong>Algorithm:</strong> Interval Scheduling (Greedy)<br>
     <strong>Efficiency:</strong> O(n log n)</p>
  <pre>
Pseudocode:
1. Sort jobs by finish time
2. For each job:
   If slot free, assign

C++:
struct Job { int start, end; };
bool compare(Job a, Job b) { return a.end < b.end; }
vector<Job> schedule(vector<Job>& jobs) {
  sort(jobs.begin(), jobs.end(), compare);
  vector<Job> result;
  int lastEnd = -1;
  for (Job j : jobs) {
    if (j.start >= lastEnd) {
      result.push_back(j);
      lastEnd = j.end;
    }
  }
  return result;
}
  </pre>
</div>

<!-- Module 3 -->
<div id="m3" class="module-content">
  <h2>Smart Cotton Inventory Routing</h2>
  <p><strong>üîç What exact problem are we solving?</strong><br>
  How can we route cotton from farms to mills with minimal transport cost and maximum throughput?</p>
  <p><strong>Algorithm:</strong> Dijkstra‚Äôs Algorithm<br>
     <strong>Efficiency:</strong> O(E + V log V)</p>
  <pre>
Pseudocode:
1. Initialize distances to ‚àû
2. Use priority queue to pick nearest node
3. Update neighbors if shorter path found

C++:
vector<int> dijkstra(int V, vector<vector<pair<int,int>>>& adj, int src) {
  vector<int> dist(V, INT_MAX);
  priority_queue<pair<int,int>, vector<pair<int,int>>, greater<>> pq;
  dist[src] = 0;
  pq.push({0, src});
  while (!pq.empty()) {
    int u = pq.top().second; pq.pop();
    for (auto [v, wt] : adj[u]) {
      if (dist[u] + wt < dist[v]) {
        dist[v] = dist[u] + wt;
        pq.push({dist[v], v});
      }
    }
  }
  return dist;
}
  </pre>
</div>

<!-- Module 4 -->
<div id="m4" class="module-content">
  <h2>EV Battery Allocation Across Zones</h2>
  <p><strong>üîç What exact problem are we solving?</strong><br>
  How can we distribute battery packs to assembly zones based on demand and capacity?</p>
  <p><strong>Algorithm:</strong> Max Flow (Ford-Fulkerson)<br>
     <strong>Efficiency:</strong> O(E √ó max_flow)</p>
  <pre>
Pseudocode:
1. Initialize flow = 0
2. While augmenting path exists:
   Find path using BFS
   Update residual graph

C++:
int fordFulkerson(int s, int t, vector<vector<int>>& capacity) {
  int flow = 0;
  vector<vector<int>> residual = capacity;
  while (bfs(s, t, residual)) {
    int path_flow = INT_MAX;
    // trace path and find min capacity
    // update residual capacities
    flow += path_flow;
  }
  return flow;
}
  </pre>
</div>

<!-- Module 5 -->
<div id="m5" class="module-content">
  <h2>Predictive Maintenance in Textile Machines</h2>
  <p><strong>üîç What exact problem are we solving?</strong><br>
  How can we predict failures in textile machines (like looms and dyeing units) before they occur, reducing downtime?</p>
  <p><strong>Algorithm:</strong> Decision Tree Classification<br>
     <strong>Efficiency:</strong> O(n log n) training, O(log n) prediction</p>
  <pre>
Pseudocode:
1. Collect labeled sensor data
2. Train decision tree on failure patterns
3. For new input:
   Traverse tree ‚Üí predict risk
4. Schedule maintenance if risk > threshold

C++:
struct Node {
  string feature;
  Node* left;
  Node* right;
  string label;
};
string predict(Node* root, map<string,string>& input) {
  while (root->left && root->right) {
    if (input[root->feature] == "yes")
      root = root->left;
    else
      root = root->right;
  }
  return root->label;
}
  </pre>
</div>

<!-- Module 6 -->
<div id="m6" class="module-content">
  <h2>Workforce Shift Scheduling</h2>
  <p><strong>üîç What exact problem are we solving?</strong><br>
  How can we assign workers to shifts fairly, respecting availability and minimizing overtime?</p>
  <p><strong>Algorithm:</strong> Hungarian Algorithm (Bipartite Matching)<br>
     <strong>Efficiency:</strong> O(n¬≥)</p>
  <pre>
Pseudocode:
1. Build cost matrix (workers √ó shifts)
2. Apply Hungarian algorithm to minimize total cost
3. Return optimal assignment

C++ (simplified):
int hungarian(const vector<vector<int>>& cost) {
  int n = cost.size();
  // Implementation of Hungarian algorithm
  // Returns minimum assignment cost
}
  </pre>
</div>

<!-- Module 7 -->
<div id="m7" class="module-content">
  <h2>Supply Chain Cost Minimization</h2>
  <p><strong>üîç What exact problem are we solving?</strong><br>
  How can we optimize raw material flow across multiple factories to minimize overall supply chain cost?</p>
  <p><strong>Algorithm:</strong> Linear Programming (Simplex Method)<br>
     <strong>Efficiency:</strong> Polynomial average time</p>
  <pre>
Pseudocode:
1. Define objective function: Minimize Œ£ (cost √ó flow)
2. Add constraints: demand, capacity, balance
3. Solve using simplex method
4. Return optimal flows

C++ (conceptual):
// Use LP solver library
// Define variables, constraints, objective
// Run simplex ‚Üí get solution
  </pre>
</div>

<script>
function toggleModule(id) {
  const modules = document.getElementsByClassName('module-content');
  for (let m of modules) {
    m.style.display = (m.id === id && m.style.display !== "block") ? "block" : "none";
  }
}
</script>

</body>
</html>
