<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Akshata ‚Äì Traffic Domain Portfolio</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      margin: 0;
      font-family: 'Segoe UI', sans-serif;
      background: #0a0a0a;
      color: #ffffff;
      text-align: center;
    }
    header {
      padding: 40px 20px;
    }
    header h1 {
      font-size: 42px;
      font-weight: 900;
      color: #e74c3c;
    }
    header h3 {
      font-size: 22px;
      font-weight: 600;
      color: #3498db;
    }
    header p {
      max-width: 800px;
      margin: 20px auto;
      font-size: 16px;
      line-height: 1.6;
      color: #dddddd;
    }

    /* Hexagon container */
    .hex-container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 30px;
      padding: 30px;
    }

    /* Hexagon base style */
    .hex {
      position: relative;
      width: 160px;
      height: 90px;
      margin: 45px 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      text-align: center;
      cursor: pointer;
      transition: transform 0.3s ease;
      color: #fff;
    }
    .hex:before,
    .hex:after {
      content: "";
      position: absolute;
      width: 0;
      border-left: 80px solid transparent;
      border-right: 80px solid transparent;
    }
    .hex:hover { transform: scale(1.08); }

    /* Different hexagon colors */
    .flow { background: #e74c3c; }
    .flow:before { border-bottom: 45px solid #e74c3c; bottom: 100%; }
    .flow:after { border-top: 45px solid #e74c3c; top: 100%; }

    .signal { background: #3498db; }
    .signal:before { border-bottom: 45px solid #3498db; bottom: 100%; }
    .signal:after { border-top: 45px solid #3498db; top: 100%; }

    .accident { background: #f1c40f; }
    .accident:before { border-bottom: 45px solid #f1c40f; bottom: 100%; }
    .accident:after { border-top: 45px solid #f1c40f; top: 100%; }

    .parking { background: #2ecc71; }
    .parking:before { border-bottom: 45px solid #2ecc71; bottom: 100%; }
    .parking:after { border-top: 45px solid #2ecc71; top: 100%; }

    .emergency { background: #9b59b6; }
    .emergency:before { border-bottom: 45px solid #9b59b6; bottom: 100%; }
    .emergency:after { border-top: 45px solid #9b59b6; top: 100%; }

    /* Popup content */
    .module-content {
      display: none;
      margin: 20px auto;
      padding: 20px;
      border-radius: 15px;
      max-width: 900px;
      color: #fff;
      background: rgba(255,255,255,0.05);
    }
    .module-content h2 { font-size: 24px; }
    .module-content p { font-size: 16px; line-height: 1.6; }
    pre {
      background: rgba(255,255,255,0.08);
      padding: 15px;
      border-radius: 10px;
      overflow-x: auto;
      font-size: 14px;
      color: #f5f5f5;
    }
  </style>
</head>
<body>

<header>
  <h1>Akshata</h1>
  <h3>Traffic Management ‚Äì Vishalnagari</h3>
  <p>
    The Traffic domain focuses on <strong>flow optimization, signal scheduling, accident detection, parking allocation, and emergency routing</strong>.  
    Algorithms such as <strong>Dijkstra, Round Robin, anomaly detection, greedy allocation, and A*</strong> are applied to ensure smoother, safer,  
    and more efficient transportation systems across Vishalnagari.
  </p>
</header>
<div class="hex-container">
  <div class="hex flow" onclick="toggleModule('a1')">Module 1: Traffic Flow</div>
  <div class="hex signal" onclick="toggleModule('a2')">Module 2: Signal Scheduling</div>
  <div class="hex accident" onclick="toggleModule('a3')">Module 3: Accident Detection</div>
  <div class="hex parking" onclick="toggleModule('a4')">Module 4: Parking Allocation</div>
  <div class="hex emergency" onclick="toggleModule('a5')">Module 5: Emergency Routing</div>
</div>

<!-- Module 1 -->
<div id="a1" class="module-content">
  <h2>Traffic Flow Optimization</h2>
  <p><strong>üîç Problem:</strong> How can vehicles be routed through a city network to minimize congestion and travel time?</p>
  <p><strong>Algorithm:</strong> Dijkstra‚Äôs Shortest Path<br>
     <strong>Efficiency:</strong> O(E log V)</p>
  <pre>
Pseudocode:
1. Initialize all node distances to infinity except source = 0
2. Use a priority queue to pick the node with smallest distance
3. For each neighbor, update distance if shorter path found
4. Repeat until all nodes processed

C++:
vector<int> shortestPath(Graph& g, int src) {
  priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;
  vector<int> dist(g.size(), INT_MAX);
  dist[src] = 0;
  pq.push({0, src});
  while(!pq.empty()) {
    int u = pq.top().second; pq.pop();
    for(auto& edge : g[u]) {
      int v = edge.first, w = edge.second;
      if(dist[u] + w < dist[v]) {
        dist[v] = dist[u] + w;
        pq.push({dist[v], v});
      }
    }
  }
  return dist;
}
  </pre>
</div>

<!-- Module 2 -->
<div id="a2" class="module-content">
  <h2>Signal Scheduling</h2>
  <p><strong>üîç Problem:</strong> How can traffic lights be scheduled to reduce waiting time and balance flow across lanes?</p>
  <p><strong>Algorithm:</strong> Round Robin Scheduling<br>
     <strong>Efficiency:</strong> O(n)</p>
  <pre>
Pseudocode:
1. Maintain a queue of lanes
2. Assign green signal to first lane for fixed time slice
3. Rotate queue ‚Üí next lane gets green
4. Continue until all lanes served

C++:
void scheduleSignals(vector<int>& lanes, int timeSlice) {
  queue<int> q;
  for(int i=0;i<lanes.size();i++) q.push(lanes[i]);
  while(true) {
    int lane = q.front(); q.pop();
    // give green signal to lane for timeSlice
    q.push(lane);
  }
}
  </pre>
</div>

<!-- Module 3 -->
<div id="a3" class="module-content">
  <h2>Accident Detection</h2>
  <p><strong>üîç Problem:</strong> How can anomalies in traffic flow be detected quickly to identify accidents or blockages?</p>
  <p><strong>Algorithm:</strong> Hash Map Anomaly Detection<br>
     <strong>Efficiency:</strong> O(1) average lookup</p>
  <pre>
Pseudocode:
1. Maintain map of lane ‚Üí vehicle count
2. Update counts periodically
3. If count drops below threshold unexpectedly ‚Üí flag accident

C++:
bool detectAccident(map<int,int>& flow, int threshold) {
  for(auto& f:flow) {
    if(f.second < threshold) return true;
  }
  return false;
}
  </pre>
</div>
      <!-- Module 4 -->
<div id="a4" class="module-content">
  <h2>Parking Allocation</h2>
  <p><strong>üîç Problem:</strong> How can limited parking slots be allocated fairly and efficiently among incoming vehicles?</p>
  <p><strong>Algorithm:</strong> Greedy Allocation<br>
     <strong>Efficiency:</strong> O(n log n)</p>
  <pre>
Pseudocode:
1. Sort parking slots by availability or distance from entry
2. Assign slots to cars in order of arrival
3. If slot is occupied, move to next available slot
4. Continue until all cars are parked or slots are full

C++:
vector<int> allocateParking(vector<int>& slots, int cars) {
  sort(slots.begin(), slots.end()); // sort slots
  vector<int> assigned;
  for(int i=0; i<cars && i<slots.size(); i++) {
    assigned.push_back(slots[i]); // assign slot
  }
  return assigned;
}
  </pre>
</div>

<!-- Module 5 -->
<div id="a5" class="module-content">
  <h2>Emergency Vehicle Routing</h2>
  <p><strong>üîç Problem:</strong> How can ambulances and fire trucks reach destinations fastest while avoiding congested roads?</p>
  <p><strong>Algorithm:</strong> A* Search Algorithm<br>
     <strong>Efficiency:</strong> O(E log V)</p>
  <pre>
Pseudocode:
1. Initialize open set with start node
2. For each node, compute f(n) = g(n) + h(n)
   - g(n) = cost from start
   - h(n) = heuristic (estimated distance to goal)
3. Expand node with lowest f(n)
4. Repeat until goal is reached

C++:
vector<int> routeEmergency(Graph& g, int src, int dest) {
  // A* search with heuristic
  // Use priority queue with f(n) values
}
  </pre>
</div>

<!-- Conclusion -->
<section style="margin:40px auto; max-width:900px; padding:20px; background:rgba(255,255,255,0.05); border-radius:15px;">
  <h2>Conclusion</h2>
  <p>
    The Traffic domain integrates <strong>flow optimization, signal scheduling, accident detection, parking allocation, and emergency routing</strong>  
    into a unified civic framework. By applying algorithmic strategies such as <strong>Dijkstra, Round Robin, anomaly detection, greedy allocation, and A*</strong>,  
    Vishalnagari ensures smoother, safer, and more efficient transportation systems for its citizens.
  </p>
</section>

<!-- Toggle Script -->
<script>
function toggleModule(id) {
  // Hide all modules first
  const modules = document.getElementsByClassName('module-content');
  for (let m of modules) {
    m.style.display = "none";
  }
  // Show the one you clicked
  const selected = document.getElementById(id);
  if (selected) {
    selected.style.display = "block";
  }
}
</script>

</body>
</html>
